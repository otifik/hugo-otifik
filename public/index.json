[{"content":"区别 在apk安装的时候，mipmap-xxx/下的所有分辨率的图片都会保留，而drawablexxx/下的图片只有保留适配设备分辨率的图片，其余图片会丢弃掉，减少了APP安装大小。\nIt’s best practice to place your app icons in mipmap- folders (not the drawable-folders) because they are used at resolutions different from the device’s current density。——from Android Developers Blog\nUsing a mipmap as the source for your bitmap or drawable is a simple way to provide a quality image and various image scales, which can be particularly useful if you expect your image to be scaled during an animation. ——from android-4.3\nif you are building different versions of your app for different densities, you should know about the “mipmap” resource directory. This is exactly like “drawable” resources, except it does not participate in density stripping when creating the different apk targets. ——from Google+ Message\n用法 mipmapxxx/下放置APP启动图标，以及需要高质量缩放动画的图片。 其他图片资源放在drawablexxx/下\n","permalink":"https://www.otifik.xyz/posts/tech/android-mipmap-drawable/","summary":"区别 在apk安装的时候，mipmap-xxx/下的所有分辨率的图片都会保留，而drawablexxx/下的图片只有保留适配设备分辨率的图片，其余图片会丢弃掉，减少了APP安装大小。\nIt’s best practice to place your app icons in mipmap- folders (not the drawable-folders) because they are used at resolutions different from the device’s current density。——from Android Developers Blog\nUsing a mipmap as the source for your bitmap or drawable is a simple way to provide a quality image and various image scales, which can be particularly useful if you expect your image to be scaled during an animation.","title":"Android mipmap与drawable区别"},{"content":"泛型擦除机制：编译器会将T这样的泛型擦除成Object，虚拟机本身是不知道泛型的。Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。\n编译器看到的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 虚拟机看到的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Foo{ private Object bar; public Foo(Object bar) { this.bar = bar; } public Object getBar() { return bar; } public void setBar(Object bar) { this.bar = bar; } } extends通配符/协变 java extends通配符 \u0026lt;? extends T\u0026gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）；协变。out，类似于fun(T: Number)。\n这段代码中，Foo是一个泛型类型，有一个bar参数，Main类中的static方法reset包含一个Foo类型的参数f。main函数运行，创建一个Foo类型的变量传入reset中，虽然Integer是Number的子类，但显然Foo并不是Foo的子类，但是如果能编译通过，reset函数中f调用getBar得到一个Integer类型的值赋值给Number是完全可行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f = new Foo\u0026lt;Integer\u0026gt;(100); int res = reset(f); //\u0026#39;reset(Foo\u0026lt;java.lang.Number\u0026gt;)\u0026#39; in \u0026#39;Main\u0026#39; cannot be applied to \u0026#39;(Foo\u0026lt;java.lang.Integer\u0026gt;)\u0026#39; System.out.println(res); } static int reset(Foo\u0026lt;Number\u0026gt; f){ Number bar = f.getBar(); return bar.intValue(); } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 所以我们可以使用\u0026lt;? extends T\u0026gt;这样的上界通配符，来让“Foo成为Foo的子类型”，除此之外可以传入Foo、Foo等类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f = new Foo\u0026lt;Integer\u0026gt;(100); int res = reset(f); System.out.println(res); } static int reset(Foo\u0026lt;? extends Number\u0026gt; f){ Number bar = f.getBar(); return bar.intValue(); } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 但是需要注意的是，reset中不能调用setBar函数，因为f的类型是不明确的，是Foo\u0026lt;? extends Number\u0026gt;，它既可能是符合要求的Foo，也可能是Foo，类型转换会出现异常。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f = new Foo\u0026lt;Integer\u0026gt;(100); int res = reset(f); System.out.println(res); } static int reset(Foo\u0026lt;? extends Number\u0026gt; f){ Number bar = f.getBar(); f.setBar(new Integer(1)); //报错：\u0026#39;setBar(capture\u0026lt;? extends java.lang.Number\u0026gt;)\u0026#39; in \u0026#39;Foo\u0026#39; cannot be applied to \u0026#39;(java.lang.Integer)\u0026#39; return f.getBar().intValue(); } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 这是\u0026lt;? extends T\u0026gt;的一个重要限制，set\u0026lt;? extends T\u0026gt;方法无法传递任何T的子类型给set\u0026lt;? extends T\u0026gt;。 通俗易懂的解释，我可以去拿这个里面的东西，但是想要改变这个东西的话，由于我不知道他是什么类型的，一旦进行改变就可能会出现类型转换异常。 我拥有子类的能力去取东西，但我要去改变的时候，我不知道他的类型是什么。\n这里唯一的例外是可以给方法参数传入null：\n1 2 f.setBar(null); // ok, 但是后面会抛出NullPointerException f.getBar(); // NullPointerException kotlin 协变 kotlin中的泛型协变亦是如此。 上面的java例子改造成kotlin，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 fun main() { val f = Foo(100) val res = reset(f) //报错：Type mismatch: inferred type is Foo\u0026lt;Int\u0026gt; but Foo\u0026lt;Number\u0026gt; was expected println(res) } fun reset(f: Foo\u0026lt;Number\u0026gt;): Int{ val bar = f.bar return bar.toInt() } class Foo\u0026lt;T\u0026gt;(var bar: T) 这时kotlin可以利用out关键字进行泛型的协变。\n1 2 3 4 5 6 7 8 9 10 11 12 fun main() { val f = Foo(100) val res = reset(f) println(res) } fun reset(f: Foo\u0026lt;out Number\u0026gt;): Int{ val bar = f.bar return bar.toInt() } class Foo\u0026lt;T\u0026gt;(var bar: T) out从字面意思上来理解就是只能拿取获得，可以读不可写的意思，对应get，报错原因同上，这里不在进行解释了。\nsuper通配符/逆变 java super通配符 \u0026lt;? super T\u0026gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。逆变。in\n这段代码中，Foo是一个泛型类型，有一个bar参数，Main类中的static方法reset包含一个Foo类型的参数f和一个Integer类型的i。main函数运行，创建一个Foo类型的变量f1传入reset中，正常可以通过编译；接着创建一个Foo类型的变量f2传入reset中，可以发现编译器报错了，原因是类型不匹配，但假如这段代码编译能够通过，Foo类型的f2变量完全可以调用setBar来把Number类型的bar值设置为一个Integer类型，因为Integer类型是Number类型的子类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f1 = new Foo\u0026lt;Integer\u0026gt;(100); Foo\u0026lt;Number\u0026gt; f2 = new Foo\u0026lt;\u0026gt;(200); reset(f1,new Integer(1)); reset(f2,new Integer(1)); //报错：\u0026#39;reset(Foo\u0026lt;java.lang.Integer\u0026gt;, java.lang.Integer)\u0026#39; in \u0026#39;Main\u0026#39; cannot be applied to \u0026#39;(Foo\u0026lt;java.lang.Number\u0026gt;, java.lang.Integer)\u0026#39; } static void reset(Foo\u0026lt;Integer\u0026gt; f,Integer i){ f.setBar(i); } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 所以我们可以使用\u0026lt;? super T\u0026gt;这样的通配符，让“Foo成为Foo的子类”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f1 = new Foo\u0026lt;Integer\u0026gt;(100); Foo\u0026lt;Number\u0026gt; f2 = new Foo\u0026lt;\u0026gt;(200); reset(f1,new Integer(1)); reset(f2,new Integer(1)); } static void reset(Foo\u0026lt;? super Integer\u0026gt; f,Integer i){ f.setBar(i); } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 但是需要注意的是，reset中不能调用getBar函数，因为f的类型是不明确的，是Foo\u0026lt;? super Integer\u0026gt;，它既可能是的Foo，也可能是Foo，类型转换会出现异常。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Main { public static void main(String[] args) { Foo\u0026lt;Integer\u0026gt; f1 = new Foo\u0026lt;Integer\u0026gt;(100); Foo\u0026lt;Number\u0026gt; f2 = new Foo\u0026lt;\u0026gt;(200); reset(f1,new Integer(1)); reset(f2,new Integer(1)); } static void reset(Foo\u0026lt;? super Integer\u0026gt; f,Integer i){ f.setBar(i); Integer bar = f.getBar(); //报错：Incompatible types. Found: \u0026#39;capture\u0026lt;? super java.lang.Integer\u0026gt;\u0026#39;, required: \u0026#39;java.lang.Integer\u0026#39; } } class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 我拥有父类的能力去给改变东西，但如果我自己拿一个东西，我不知道他的类型是什么。 但有个特殊情况，唯一可以接收getFirst()方法返回值的是Object类型，如下：\n1 Object bar = f.getBar(); kotlin 逆变 kotlin中亦是如此，不做过多阐述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun main() { val f1 = Foo\u0026lt;Int\u0026gt;(100) val f2 = Foo\u0026lt;Number\u0026gt;(200) reset(f1,1) reset(f2,1) //报错：Type mismatch: inferred type is Foo\u0026lt;Number\u0026gt; but Foo\u0026lt;Int\u0026gt; was expected } fun reset(f: Foo\u0026lt;Int\u0026gt;,i: Int){ f.bar = i } class Foo\u0026lt;T\u0026gt;(var bar: T) 增加in关键字，进行逆变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun main() { val f1 = Foo\u0026lt;Int\u0026gt;(100) val f2 = Foo\u0026lt;Number\u0026gt;(200) reset(f1,1) reset(f2,1) } fun reset(f: Foo\u0026lt;in Int\u0026gt;,i: Int){ f.bar = i } class Foo\u0026lt;T\u0026gt;(var bar: T) in从字面意思上来理解就是只能给予，可以写不可读的意思，对应out。\nPECS原则：Producer Extends Consumer Super。即：如果需要返回T，它是生产者（Producer），要使用extends通配符/out；如果需要写入T，它是消费者（Consumer），要使用super通配符/in。\nq1: java中为什么Foo和Foo没有继承关系？Number不是Integer的父类吗？\na1: 在Java中，Pair和Pair之间没有继承关系。虽然Number是Integer的父类，但是泛型不支持协变（covariance）或逆变（contravariance）的类型参数继承。\n1 2 3 Foo\u0026lt;Number\u0026gt; numberFoo = new Foo\u0026lt;\u0026gt;(10); Foo\u0026lt;Integer\u0026gt; integerFoo = new Foo\u0026lt;\u0026gt;(20); numberFoo = integerFoo; // 编译错误 在这个例子中，如果Foo和Foo之间存在继承关系，那么将integerFoo赋值给numberFoo应该是合法的。然而，Java中的泛型是不可变的（invariant），这意味着即使Integer是Number的子类型，Foo和Foo之间没有继承关系，无法进行赋值。\n","permalink":"https://www.otifik.xyz/posts/tech/kotlin-generics/","summary":"泛型擦除机制：编译器会将T这样的泛型擦除成Object，虚拟机本身是不知道泛型的。Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。\n编译器看到的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Foo\u0026lt;T\u0026gt;{ private T bar; public Foo(T bar) { this.bar = bar; } public T getBar() { return bar; } public void setBar(T bar) { this.bar = bar; } } 虚拟机看到的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Foo{ private Object bar; public Foo(Object bar) { this.","title":"Kotlin反射\u0026泛型"},{"content":"Kotiln的委托，简而言之，就是把让我干的事交给别人做。分为类委托和属性委托。 用于解耦代码。\n引用文章： https://blog.csdn.net/willway_wang/article/details/120795321 https://www.kotlincn.net/docs/reference/delegated-properties.html\n类委托 将接口的实现委托给另一个对象 但值得注意的是类必须实现一个接口，委托类必须是类所实现接口的子类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() { print(x) } } class Derived(b: Base) : Base by b fun main() { val b = BaseImpl(10) Derived(b).print() } kotlin转java字节码解析： by关键字自动生成了Derived的print，相当于Derived让Base的一个实现类帮它调用了print函数。 委托类的接口实现可以通过override覆写，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() { print(x) } } class Derived(b: Base) : Base by b { override fun print() { print(\u0026#34;fun has override\u0026#34;) } } fun main() { val b = BaseImpl(10) Derived(b).print() } kotlin转java字节码解析： Derived覆写了Base实现类的print 属性委托 将属性访问器的实现委托给另一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Example { var p: String by Delegate() } class Delegate : ReadWriteProperty\u0026lt;Any, String\u0026gt; { override fun getValue(thisRef: Any, property: KProperty\u0026lt;*\u0026gt;): String { return \u0026#34;$thisRef, thank you for delegating \u0026#39;${property.name}\u0026#39; to me!\u0026#34; } override fun setValue(thisRef: Any, property: KProperty\u0026lt;*\u0026gt;, value: String) { println(\u0026#34;$value has been assigned to \u0026#39;${property.name}\u0026#39; in $thisRef.\u0026#34;) } } fun main() { val e = Example() println(e.p) } 解析： 原理和类委托大致类似\n①\n1 2 3 class Example { var p: String by Delegate() } 其中这段代码可以等价为：\n1 2 3 4 5 6 class Example { private val delegate = Delegate() var p: String set(value: String) = delegate.setValue(this, ..., value) get() = delegate.getValue(this, ...) } 可以看到其实p这个属性的get/set交给了delegate来进行维护 by关键字的作用是对它后面的表达式求值（比方说lazy函数）来获取这个对象，在这里就是获取到了Delegate对象。 编译器会创建一个隐藏的辅助属性，并使用委托对象的实例对它进行初始化，在这里就是把Delegate对象赋值给了delegate属性。\nkotlin转java字节码解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public final class Example { // $FF: synthetic field static final KProperty[] $$delegatedProperties = new KProperty[]{(KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Example.class, \u0026#34;p\u0026#34;, \u0026#34;getP()Ljava/lang/String;\u0026#34;, 0))}; @NotNull private final Delegate p$delegate = new Delegate(); @NotNull public final String getP() { return this.p$delegate.getValue(this, $$delegatedProperties[0]); } public final void setP(@NotNull String var1) { Intrinsics.checkNotNullParameter(var1, \u0026#34;\u0026lt;set-?\u0026gt;\u0026#34;); this.p$delegate.setValue(this, $$delegatedProperties[0], (String)var1); } } public final class Delegate implements ReadWriteProperty { @NotNull public String getValue(@NotNull Object thisRef, @NotNull KProperty property) { Intrinsics.checkNotNullParameter(thisRef, \u0026#34;thisRef\u0026#34;); Intrinsics.checkNotNullParameter(property, \u0026#34;property\u0026#34;); return thisRef + \u0026#34;, thank you for delegating \u0026#39;\u0026#34; + property.getName() + \u0026#34;\u0026#39; to me!\u0026#34;; } // $FF: synthetic method // $FF: bridge method public Object getValue(Object var1, KProperty var2) { return this.getValue(var1, var2); } public void setValue(@NotNull Object thisRef, @NotNull KProperty property, @NotNull String value) { Intrinsics.checkNotNullParameter(thisRef, \u0026#34;thisRef\u0026#34;); Intrinsics.checkNotNullParameter(property, \u0026#34;property\u0026#34;); Intrinsics.checkNotNullParameter(value, \u0026#34;value\u0026#34;); String var4 = value + \u0026#34; has been assigned to \u0026#39;\u0026#34; + property.getName() + \u0026#34;\u0026#39; in \u0026#34; + thisRef + \u0026#39;.\u0026#39;; System.out.println(var4); } // $FF: synthetic method // $FF: bridge method public void setValue(Object var1, KProperty var2, Object var3) { this.setValue(var1, var2, (String)var3); } } public final class AKt { public static final void main() { Example e = new Example(); String var1 = e.getP(); System.out.println(var1); } // $FF: synthetic method public static void main(String[] var0) { main(); } } 其中thisRef代表发起委托的对象，$$delegatedProperties对象，它是一个KProperty类型的数组，它的元素封装了类，属性名，getter方法签名等信息，也会传递给委托类；KProperty 主要是用来封装属性的元信息，提供给委托类使用，比如在委托类的 setValue 方法中通知属性发生变化时，就会用到 KProperty 里的属性名信息了。\n②\n1 2 3 4 5 6 7 8 9 class Delegate { operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): String { return \u0026#34;$thisRef, thank you for delegating \u0026#39;${property.name}\u0026#39; to me!\u0026#34; } operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: String) { println(\u0026#34;$value has been assigned to \u0026#39;${property.name}\u0026#39; in $thisRef.\u0026#34;) } } 委托类必须具有getValue和setValue方法（如果是可变属性的话）,定义在ReadWriteProperty接口里 ReadOnlyProperty对应val，ReadWriteProperty对应var\n1 2 3 4 5 6 7 8 public fun interface ReadOnlyProperty\u0026lt;in T, out V\u0026gt; { public operator fun getValue(thisRef: T, property: KProperty\u0026lt;*\u0026gt;): V } public interface ReadWriteProperty\u0026lt;in T, V\u0026gt; : ReadOnlyProperty\u0026lt;T, V\u0026gt; { public override operator fun getValue(thisRef: T, property: KProperty\u0026lt;*\u0026gt;): V public operator fun setValue(thisRef: T, property: KProperty\u0026lt;*\u0026gt;, value: V) } 虽然 Kotlin 提供了 ReadWriteProperty 和 ReadOnlyProperty 封装了约定的方法给我们使用，但是当我们定义委托类时并不是一定要实现 Kotlin 提供的接口。\n实际上，只要保持委托类里的 setValue 和 getValue 方法与约定的 setValue 方法和 getValue 方法一致就可以了。 如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import kotlin.reflect.KProperty import kotlin.reflect.full.valueParameters class Example { var p: String by Delegate() } class Delegate { operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): String { return \u0026#34;$thisRef, thank you for delegating \u0026#39;${property.name}\u0026#39; to me!\u0026#34; } operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: String) { println(\u0026#34;$value has been assigned to \u0026#39;${property.name}\u0026#39; in $thisRef.\u0026#34;) } } fun main(){ val e = Example() println(e.p) } kotlin内置委托属性 lazy lazy()是接受一个lambda并返回一个Lazy实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用get()会执行已传递给lazy()的lambda表达式并记录结果，后续调用get()只是返回记录的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public actual fun \u0026lt;T\u0026gt; lazy(initializer: () -\u0026gt; T): Lazy\u0026lt;T\u0026gt; = SynchronizedLazyImpl(initializer) public interface Lazy\u0026lt;out T\u0026gt; { /** * Gets the lazily initialized value of the current Lazy instance. * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance. */ public val value: T /** * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise. * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance. */ public fun isInitialized(): Boolean } public inline operator fun \u0026lt;T\u0026gt; Lazy\u0026lt;T\u0026gt;.getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): T = value private class SynchronizedLazyImpl\u0026lt;out T\u0026gt;(initializer: () -\u0026gt; T, lock: Any? = null) : Lazy\u0026lt;T\u0026gt;, Serializable { private var initializer: (() -\u0026gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) return _v1 as T } return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else \u0026#34;Lazy value not initialized yet.\u0026#34; private fun writeReplace(): Any = InitializedLazyImpl(value) } 通过源码可以看出，Lazy.kt中定义了符合约定的扩展函数getValue，实例化SynchronizedLazyImpl就是委托对象。\n可观察属性 Observable Delegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：\n1 2 3 4 var name: String by Delegates.observable(\u0026#34;no name\u0026#34;) { prop, old, new -\u0026gt; println(\u0026#34;$old -\u0026gt; $new\u0026#34;) } 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public inline fun \u0026lt;T\u0026gt; observable(initialValue: T, crossinline onChange: (property: KProperty\u0026lt;*\u0026gt;, oldValue: T, newValue: T) -\u0026gt; Unit): ReadWriteProperty\u0026lt;Any?, T\u0026gt; = object : ObservableProperty\u0026lt;T\u0026gt;(initialValue) { override fun afterChange(property: KProperty\u0026lt;*\u0026gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) } public abstract class ObservableProperty\u0026lt;V\u0026gt;(initialValue: V) : ReadWriteProperty\u0026lt;Any?, V\u0026gt; { private var value = initialValue /** * The callback which is called before a change to the property value is attempted. * The value of the property hasn\u0026#39;t been changed yet, when this callback is invoked. * If the callback returns `true` the value of the property is being set to the new value, * and if the callback returns `false` the new value is discarded and the property remains its old value. */ protected open fun beforeChange(property: KProperty\u0026lt;*\u0026gt;, oldValue: V, newValue: V): Boolean = true /** * The callback which is called after the change of the property is made. The value of the property * has already been changed when this callback is invoked. */ protected open fun afterChange(property: KProperty\u0026lt;*\u0026gt;, oldValue: V, newValue: V): Unit {} public override fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): V { return value } public override fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: V) { val oldValue = this.value if (!beforeChange(property, oldValue, value)) { return } this.value = value afterChange(property, oldValue, value) } } 委托给另一个属性 从 Kotlin 1.4 开始，一个属性可以把它的 getter 与 setter 委托给另一个属性。这种委托对于顶层和类的属性（成员和扩展）都可用。该委托属性可以为：\n-顶层属性 -同一个类的成员或扩展属性 -另一个类的成员或扩展属性 为将一个属性委托给另一个属性，应在委托名称中使用恰当的::限定符，例如，this::delegate或MyClass::delegate。\n1 2 3 4 5 6 7 8 9 10 var topLevelInt: Int = 0 class ClassWithDelegate(val anotherClassInt: Int) class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) { var delegatedToMember: Int by this::memberInt var delegatedToTopLevel: Int by ::topLevelInt val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt } var MyClass.extDelegated: Int by ::topLevelInt 使用场景：当想要以一种向后兼容的方式重命名一个属性的时候：引入一个新的属性、 使用 @Deprecated 注解来注解旧的属性、并委托其实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { var newName: Int = 0 @Deprecated(\u0026#34;Use \u0026#39;newName\u0026#39; instead\u0026#34;, ReplaceWith(\u0026#34;newName\u0026#34;)) var oldName: Int by this::newName } fun main() { val myClass = MyClass() // 通知：\u0026#39;oldName: Int\u0026#39; is deprecated. // Use \u0026#39;newName\u0026#39; instead myClass.oldName = 42 println(myClass.newName) // 42 } 将属性储存在映射中 一个常见的用例是在一个映射（map）里存储属性的值。这经常出现在像解析JSON或者做其他“动态”事情的应用中。在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。\n1 2 3 4 class User(val map: Map\u0026lt;String, Any?\u0026gt;) { val name: String by map val age: Int by map } 在这个例子中，构造函数接受一个映射参数：\n1 2 3 4 val user = User(mapOf( \u0026#34;name\u0026#34; to \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34; to 25 )) 委托属性会从这个映射中取值（通过字符串键——属性的名称）：\n1 2 println(user.name) // Prints \u0026#34;John Doe\u0026#34; println(user.age) // Prints 25 这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话：\n1 2 3 4 class MutableUser(val map: MutableMap\u0026lt;String, Any?\u0026gt;) { var name: String by map var age: Int by map } 局部委托属性 你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：\n1 2 3 4 5 6 7 fun example(computeFoo: () -\u0026gt; Foo) { val memoizedFoo by lazy(computeFoo) ​ if (someCondition \u0026amp;\u0026amp; memoizedFoo.isValid()) { memoizedFoo.doSomething() } } memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。\n提供委托 通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。\nprovideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class ResourceDelegate\u0026lt;T\u0026gt; : ReadOnlyProperty\u0026lt;MyUI, T\u0026gt; { override fun getValue(thisRef: MyUI, property: KProperty\u0026lt;*\u0026gt;): T { ... } } class ResourceLoader\u0026lt;T\u0026gt;(id: ResourceID\u0026lt;T\u0026gt;) { operator fun provideDelegate( thisRef: MyUI, prop: KProperty\u0026lt;*\u0026gt; ): ReadOnlyProperty\u0026lt;MyUI, T\u0026gt; { checkProperty(thisRef, prop.name) // 创建委托 return ResourceDelegate() } private fun checkProperty(thisRef: MyUI, name: String) { …… } } class MyUI { fun \u0026lt;T\u0026gt; bindResource(id: ResourceID\u0026lt;T\u0026gt;): ResourceLoader\u0026lt;T\u0026gt; { …… } val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id) } prop.name，此处prop指的是被委托属性对象，因此prop.name就是属性的名称，在 checkProperty(thisRef, prop.name)中即可自行检查属性一致性，检查无误后，即可通过返回的getValue完成属性委托\n","permalink":"https://www.otifik.xyz/posts/tech/kotlin-delegate/","summary":"Kotiln的委托，简而言之，就是把让我干的事交给别人做。分为类委托和属性委托。 用于解耦代码。\n引用文章： https://blog.csdn.net/willway_wang/article/details/120795321 https://www.kotlincn.net/docs/reference/delegated-properties.html\n类委托 将接口的实现委托给另一个对象 但值得注意的是类必须实现一个接口，委托类必须是类所实现接口的子类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() { print(x) } } class Derived(b: Base) : Base by b fun main() { val b = BaseImpl(10) Derived(b).print() } kotlin转java字节码解析： by关键字自动生成了Derived的print，相当于Derived让Base的一个实现类帮它调用了print函数。 委托类的接口实现可以通过override覆写，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface Base { fun print() } class BaseImpl(val x: Int) : Base { override fun print() { print(x) } } class Derived(b: Base) : Base by b { override fun print() { print(\u0026#34;fun has override\u0026#34;) } } fun main() { val b = BaseImpl(10) Derived(b).","title":"Kotlin委托深究"},{"content":"iPad文件传输到windows 处于同一wifi下的iPad与windows文件传输，务必阅读完再进行操作，亲测13g视频花了大概十分钟不到\n准备工作：打开SMB 控制面板-程序-启用或关闭windows功能\n确定后重启电脑\n创建共享文件夹 任意位置新建文件夹，右键属性-共享\n点击共享\n选择自己的账号并添加，然后点击共享（一般都默认会有自己的账号，没有的情况请自行创建一个本地账号）\niPad连接 然后iPad上打开文件，点击三个点图标-连接服务器\n输入smb://+电脑端的ip地址（cmd通过ipconfig获取，不多赘述）\n选择注册用户，输入windows用户名和密码\n用户就是C:/Users下的用户，密码就是pin\n上传文件至共享文件夹 点击分享-存储到文件，然后直接点共享文件夹存进去就好啦\n","permalink":"https://www.otifik.xyz/posts/tech/ipadtowindows/","summary":"iPad文件传输到windows 处于同一wifi下的iPad与windows文件传输，务必阅读完再进行操作，亲测13g视频花了大概十分钟不到\n准备工作：打开SMB 控制面板-程序-启用或关闭windows功能\n确定后重启电脑\n创建共享文件夹 任意位置新建文件夹，右键属性-共享\n点击共享\n选择自己的账号并添加，然后点击共享（一般都默认会有自己的账号，没有的情况请自行创建一个本地账号）\niPad连接 然后iPad上打开文件，点击三个点图标-连接服务器\n输入smb://+电脑端的ip地址（cmd通过ipconfig获取，不多赘述）\n选择注册用户，输入windows用户名和密码\n用户就是C:/Users下的用户，密码就是pin\n上传文件至共享文件夹 点击分享-存储到文件，然后直接点共享文件夹存进去就好啦","title":"iPad文件传输到windows"},{"content":"Scoop windows包管理器\n安装 管理员模式打开PowerShell，设置用户安装路径和全局安装路径，\n1 2 3 4 $env:SCOOP=\u0026#39;D:\\Scoop\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP\u0026#39;, $env:SCOOP, \u0026#39;User\u0026#39;) $env:SCOOP_GLOBAL=\u0026#39;D:\\ScoopGlobal\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, $env:SCOOP_GLOBAL, \u0026#39;Machine\u0026#39;) 设置PowerShell执行策略为RemoteSigned\n1 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 安装Scoop\n1 iwr -useb get.scoop.sh | iex Scoop中安装git\n1 scoop install git 最好打开git初始化一下，否则会出现timeout等情况\n使用 添加bucket 1 scoop bucket add \u0026lt;bucketname\u0026gt; 安装软件 1 scoop install \u0026lt;app\u0026gt; 管理软件缓存 1 2 3 scoop cache show #显示安装包缓存 scoop cache rm \u0026lt;app\u0026gt; #删除指定应用的安装包缓存 scoop cache rm * #删除所有的安装包缓存 全局安装软件 1 scoop install -g \u0026lt;app\u0026gt; Aria2多线程下载 1 scoop install aria2 配置相关设置\n1 2 3 scoop config aria2-split 32#单任务最大连接数设置为32 scoop config aria2-max-connection-per-server 16#单服务器最大连接数设置为16 scoop config aria2-min-split-size 1M#最小文件分片大小设置为1M 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 更新 scoop 及软件包列表 scoop update ## 安装软件 ## # 非全局安装（并禁止安装包缓存） scoop install -k \u0026lt;app\u0026gt; # 全局安装（并禁止安装包缓存） sudo scoop install -gk \u0026lt;app\u0026gt; ## 卸载软件 ## # 卸载非全局软件（并删除配置文件） scoop uninstall -p \u0026lt;app\u0026gt; # 卸载全局软件（并删除配置文件） sudo scoop uninstall -gp \u0026lt;app\u0026gt; ## 更新软件 ## # 更新所有非全局软件（并禁止安装包缓存） scoop update -k * # 更新所有软件（并禁止安装包缓存） sudo scoop update -gk * ## 垃圾清理 ## # 删除所有旧版本非全局软件（并删除软件包缓存） scoop cleanup -k * # 删除所有旧版本软件（并删除软件包缓存） sudo scoop cleanup -gk * # 清除软件包缓存 scoop cache rm * ","permalink":"https://www.otifik.xyz/posts/tech/scoop/","summary":"Scoop windows包管理器\n安装 管理员模式打开PowerShell，设置用户安装路径和全局安装路径，\n1 2 3 4 $env:SCOOP=\u0026#39;D:\\Scoop\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP\u0026#39;, $env:SCOOP, \u0026#39;User\u0026#39;) $env:SCOOP_GLOBAL=\u0026#39;D:\\ScoopGlobal\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, $env:SCOOP_GLOBAL, \u0026#39;Machine\u0026#39;) 设置PowerShell执行策略为RemoteSigned\n1 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 安装Scoop\n1 iwr -useb get.scoop.sh | iex Scoop中安装git\n1 scoop install git 最好打开git初始化一下，否则会出现timeout等情况\n使用 添加bucket 1 scoop bucket add \u0026lt;bucketname\u0026gt; 安装软件 1 scoop install \u0026lt;app\u0026gt; 管理软件缓存 1 2 3 scoop cache show #显示安装包缓存 scoop cache rm \u0026lt;app\u0026gt; #删除指定应用的安装包缓存 scoop cache rm * #删除所有的安装包缓存 全局安装软件 1 scoop install -g \u0026lt;app\u0026gt; Aria2多线程下载 1 scoop install aria2 配置相关设置","title":"Scoop的安装使用"},{"content":"多的就不多说啦，下面是我个人的绘画记录（按时间排序）\n绘画记录 2014.1.30 2022.6.19 2022.6.22 2022.9.15 2022.9.22 2022.9.26 2022.11.6 2022.12.17 2023.1.11 ","permalink":"https://www.otifik.xyz/posts/painting/record/","summary":"多的就不多说啦，下面是我个人的绘画记录（按时间排序）\n绘画记录 2014.1.30 2022.6.19 2022.6.22 2022.9.15 2022.9.22 2022.9.26 2022.11.6 2022.12.17 2023.1.11 ","title":"绘画生涯记录"},{"content":"如何用esp8266开发板控制sg90进行旋转 所需工具 硬件准备：\n1.esp8266 CH340开发板\n2.sg90舵机\n3.杜邦线若干\n4.一根microusb数据线（不同usb数据线的区别）\n请注意不同usb数据线的区别！！！\n一般有两种usb数据线，一种是充电线，另一种是数据线。\n充电线和数据线的区别在于充电线无法传输数据，而数据线可以传输数据。\n一般数据线和充电线都是用USB接口的，一般都会有四根线。充电线用到的是电源的VCC和GND这两个线，而数据线是用到VCC，GND，和两根通信线。数据线在USB接口那跟线里有四条线，而电源线在USB那个线里有两条线，所以，数据线可以当电源线，而电源线不能用作数据线。\n如果插入电脑驱动安装无反应请选择别的数据线。\n请选择正确的数据线以保证开发板连接电脑时能正常安装驱动！！！\n数据线的接线方式\n红线：电源正极（接线上的标识为：+5V或VCC）\n白线：负电压数据线（标识为：Data-或USB Port -）\n绿线：正电压数据线（标识为：Data+或USB Port +）\n黑线：接地（标识为：GROUND或GND）\n充电线的接线方式\n红线：电源正极（接线上的标识为：+5V或VCC）\n黑线：接地（标识为：GROUND或GND）\n软件准备：\n1.Arduino IDE（官网安装）\n2.驱动\n3.串口调试助手（通过Microsoft Store进行安装）\n安装驱动\n驱动下载链接：https://www.wch.cn/download/CH341SER_EXE.html\n1.将开发板通过usb数据线连接至电脑\n2.启动CH341SER.EXE并进行安装\n3.通过设备管理器查看是否安装成功\n原理 esp8266开发板作为服务器，客户端通过访问服务器的页面来控制sg90舵机进行旋转\n步骤 1.接线\n引脚说明图\n如图\n全景\nesp视角\n杜邦线视角\n原理解释\n2.代码编写\nServo库运用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;Servo.h\u0026gt; #include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;ESP8266WebServer.h\u0026gt; //WiFi名称\u0026amp;密码 const char* ssid = \u0026#34;Redmi_97DD\u0026#34;; const char* password = \u0026#34;12345678\u0026#34;; ESP8266WebServer server(80); Servo servo; String html = \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;html lang=\\\u0026#34;en\\\u0026#34;\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta charest=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;\u0026lt;a href=\\\u0026#34;./swi?light=on\\\u0026#34;\u0026gt;\u0026lt;input type=\\\u0026#34;button\\\u0026#34; value=\\\u0026#34;\u0026amp;#x5F00;\u0026amp;#x706F;\\\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\\\u0026#34;./swi?light=off\\\u0026#34;\u0026gt;\u0026lt;input type=\\\u0026#34;button\\\u0026#34; value=\\\u0026#34;\u0026amp;#x5173;\u0026amp;#x706F;\\\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; String onJson = \u0026#34;{\\\u0026#34;msg\\\u0026#34;: 200,\\\u0026#34;light\\\u0026#34;: \\\u0026#34;on\\\u0026#34;}\u0026#34;; String offJson = \u0026#34;{\\\u0026#34;msg\\\u0026#34;: 200,\\\u0026#34;light\\\u0026#34;: \\\u0026#34;off\\\u0026#34;}\u0026#34;; void swi(){ if(server.arg(\u0026#34;light\u0026#34;)==\u0026#34;on\u0026#34;){ server.send(200, \u0026#34;application/json\u0026#34;, onJson); servo.write(180); delay(1000); servo.write(90); }else if(server.arg(\u0026#34;light\u0026#34;)==\u0026#34;off\u0026#34;){ server.send(200, \u0026#34;application/json\u0026#34;, offJson); servo.write(0); delay(1000); servo.write(90); } } void handleRoot() { server.send(200, \u0026#34;text/html\u0026#34;, html); } void handleNotFound(){ server.send(404, \u0026#34;text/plain\u0026#34;, \u0026#34;404: Not found\u0026#34;); } void setup() { Serial.begin(9600); Serial.println(\u0026#34;\u0026#34;); servo.attach(D5); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); Serial.print(\u0026#34;\\r\\nConnecting to \u0026#34;); Serial.print(ssid); Serial.println(\u0026#34; ...\u0026#34;); int i = 0; while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.print(\u0026#34;waiting for \u0026#34;); Serial.print(i++); Serial.println(\u0026#34;s...\u0026#34;); } Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;WiFi connected!\u0026#34;); Serial.print(\u0026#34;IP address: \u0026#34;); Serial.println(WiFi.localIP()); server.begin(); server.on(\u0026#34;/\u0026#34;, handleRoot); server.on(\u0026#34;/swi\u0026#34;,HTTP_GET, swi); server.onNotFound(handleNotFound); Serial.println(\u0026#34;HTTP server started\u0026#34;); } void loop() { server.handleClient(); } 3.烧录代码并为开发板接电源\n4.通过ip地址访问esp服务器\n电脑端通过打印出的ip地址直接进行访问，效果如下：\n现在就可以直接通过按钮进行舵机的控制。\n","permalink":"https://www.otifik.xyz/posts/tech/esp8266_sg90/","summary":"如何用esp8266开发板控制sg90进行旋转 所需工具 硬件准备：\n1.esp8266 CH340开发板\n2.sg90舵机\n3.杜邦线若干\n4.一根microusb数据线（不同usb数据线的区别）\n请注意不同usb数据线的区别！！！\n一般有两种usb数据线，一种是充电线，另一种是数据线。\n充电线和数据线的区别在于充电线无法传输数据，而数据线可以传输数据。\n一般数据线和充电线都是用USB接口的，一般都会有四根线。充电线用到的是电源的VCC和GND这两个线，而数据线是用到VCC，GND，和两根通信线。数据线在USB接口那跟线里有四条线，而电源线在USB那个线里有两条线，所以，数据线可以当电源线，而电源线不能用作数据线。\n如果插入电脑驱动安装无反应请选择别的数据线。\n请选择正确的数据线以保证开发板连接电脑时能正常安装驱动！！！\n数据线的接线方式\n红线：电源正极（接线上的标识为：+5V或VCC）\n白线：负电压数据线（标识为：Data-或USB Port -）\n绿线：正电压数据线（标识为：Data+或USB Port +）\n黑线：接地（标识为：GROUND或GND）\n充电线的接线方式\n红线：电源正极（接线上的标识为：+5V或VCC）\n黑线：接地（标识为：GROUND或GND）\n软件准备：\n1.Arduino IDE（官网安装）\n2.驱动\n3.串口调试助手（通过Microsoft Store进行安装）\n安装驱动\n驱动下载链接：https://www.wch.cn/download/CH341SER_EXE.html\n1.将开发板通过usb数据线连接至电脑\n2.启动CH341SER.EXE并进行安装\n3.通过设备管理器查看是否安装成功\n原理 esp8266开发板作为服务器，客户端通过访问服务器的页面来控制sg90舵机进行旋转\n步骤 1.接线\n引脚说明图\n如图\n全景\nesp视角\n杜邦线视角\n原理解释\n2.代码编写\nServo库运用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;Servo.","title":"通过ESP8266CH340控制sg90舵机"},{"content":"B站上可以看到一部分手元视频哦 指路👉我喂摸鱼袋盐\nMalody 通过malody regular dan v2 3 (2022/10/20) 通过malody regular dan v3 4 (2022/11/18) 通过malody regular dan v3 5 (2022/2/24) 通过malody regular dan v3 6 (2022/4/22) Project Sekai Phigros BanG! Dream ","permalink":"https://www.otifik.xyz/posts/other/rhythmgame/","summary":"B站上可以看到一部分手元视频哦 指路👉我喂摸鱼袋盐\nMalody 通过malody regular dan v2 3 (2022/10/20) 通过malody regular dan v3 4 (2022/11/18) 通过malody regular dan v3 5 (2022/2/24) 通过malody regular dan v3 6 (2022/4/22) Project Sekai Phigros BanG! Dream ","title":"音游生涯记录(流量警告)"}]